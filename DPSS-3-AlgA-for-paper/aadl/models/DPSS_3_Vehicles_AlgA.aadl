package DPSS_3_Vehicles_AlgA_Pkg
public
--	with DPSS_Data_Types;
	with DPSS_Node_Lib;
	with DPSS_Constants;
	with UAV_Pkg;
	with Base_Types;
	
	system DPSS_3_Vehicles_AlgA
		features
			-----------------------------------------------------
			--INPUTS
			-----------------------------------------------------
			
			--Initial positions
			initial_pos_UAV1 : in data port Base_Types::Float;
			initial_pos_UAV2 : in data port Base_Types::Float;
			initial_pos_UAV3 : in data port Base_Types::Float;
						
			--Initial directions
			initial_direction_UAV1 : in data port Base_Types::Integer;
			initial_direction_UAV2 : in data port Base_Types::Integer;
			initial_direction_UAV3 : in data port Base_Types::Integer;
			
			-----------------------------------------------------
			--OUTPUTS
			-----------------------------------------------------

			pos_UAV1 : out data port Base_Types::Float;
			pos_UAV2 : out data port Base_Types::Float;
			pos_UAV3 : out data port Base_Types::Float;
			 
		annex agree {**
			-----------------------------------------------------
			--EQ (STATE) VARIABLES
			-----------------------------------------------------
					
			--Directions
			eq direction_UAV1 : int;
			eq direction_UAV2 : int;
			eq direction_UAV3 : int;

			--Goals
			eq goal_UAV1 : real;
			eq goal_UAV2 : real;
			eq goal_UAV3 : real;
			
			--Shared border positions
			eq P_12 : real = 1.0*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;  
			eq P_23 : real = 2.0*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;
			
			--Previous positions
			eq pre_pos_UAV1 : real = prev(pos_UAV1, initial_pos_UAV1);
			eq pre_pos_UAV2 : real = prev(pos_UAV2, initial_pos_UAV2);
			eq pre_pos_UAV3 : real = prev(pos_UAV3, initial_pos_UAV3);
			
			--Previous directions
			eq pre_direction_UAV1 : int = prev(direction_UAV1, initial_direction_UAV1);
			eq pre_direction_UAV2 : int = prev(direction_UAV2, initial_direction_UAV2);
			eq pre_direction_UAV3 : int = prev(direction_UAV3, initial_direction_UAV3);
			
			--Previous goals
			eq pre_goal_UAV1 : real = prev(goal_UAV1, (if direction_UAV1 = DPSS_Constants.RIGHT then DPSS_Constants.P_GLOBAL else 0.0));
			eq pre_goal_UAV2 : real = prev(goal_UAV2, (if direction_UAV2 = DPSS_Constants.RIGHT then DPSS_Constants.P_GLOBAL else 0.0));
			eq pre_goal_UAV3 : real = prev(goal_UAV3, (if direction_UAV3 = DPSS_Constants.RIGHT then DPSS_Constants.P_GLOBAL else 0.0));
						
			--Times to reach neighbors													
			eq time_to_reach_neighbor_12 : real = 
				DPSS_Node_Lib.time_to_reach_neighbor(pre_direction_UAV1,
														pre_direction_UAV2,
														pre_pos_UAV1,
														pre_pos_UAV2
														);
						 												
			eq time_to_reach_neighbor_23 : real = 
				DPSS_Node_Lib.time_to_reach_neighbor(pre_direction_UAV2,
														pre_direction_UAV3,
														pre_pos_UAV2,
														pre_pos_UAV3
														);
			
			--Times to reach goals
			eq time_until_UAV1_reaches_goal : real = 
				DPSS_Node_Lib.time_to_reach_target_position(
					pre_direction_UAV1, 
					pre_pos_UAV1, 
					pre_goal_UAV1
				);
				
			eq time_until_UAV2_reaches_goal : real = 
				DPSS_Node_Lib.time_to_reach_target_position(
					pre_direction_UAV2, 
					pre_pos_UAV2, 
					pre_goal_UAV2
				);
				
			eq time_until_UAV3_reaches_goal : real = 
				DPSS_Node_Lib.time_to_reach_target_position(
					pre_direction_UAV3, 
					pre_pos_UAV3, 
					pre_goal_UAV3
				);
			
			eq deltaT : real = 
							DPSS_Node_Lib.min_time(time_until_UAV1_reaches_goal,
							DPSS_Node_Lib.min_time(time_until_UAV2_reaches_goal,
							DPSS_Node_Lib.min_time(time_until_UAV3_reaches_goal,
							DPSS_Node_Lib.min_time(time_to_reach_neighbor_12,
												   time_to_reach_neighbor_23))));
			
			eq optimal : bool = 
				--Either the UAVs are at 0, P_23, and P_23
				--and were previously at P_12, P_12, and P
				(	
					(
						pos_UAV1 = 0.0 and 
						pos_UAV2 = P_23 and 
						pos_UAV3 = P_23 
					)
					and (
						pre_pos_UAV1 = P_12 and 
						pre_pos_UAV2 = P_12 and 
						pre_pos_UAV3 = DPSS_Constants.P_GLOBAL
					)
				)
				--or the UAVs are at P_12, P_12, and P
				--and were previously at 0, P_23, and P_23
				or (
					(
						pos_UAV1 = P_12 and 
						pos_UAV2 = P_12 and 
						pos_UAV3 = DPSS_Constants.P_GLOBAL
					)
					and (
						pre_pos_UAV1 = 0.0 and 
						pre_pos_UAV2 = P_23 and 
						pre_pos_UAV3 = P_23 
					)
				);
						
			-----------------------------------------------------
			--ASSUMPTIONS
			-----------------------------------------------------
			
			assume "time update": time = (0.0 -> pre(time) + deltaT);
			
			assume "UAVs are numbered according to their position from left to right":
				(	initial_pos_UAV1 <= initial_pos_UAV2
				and initial_pos_UAV2 <= initial_pos_UAV3)
				-> true;
				
			assume "Initial positions are between perimeter endpoints":
				(--Initial positions are >= 0
					0.0 <= initial_pos_UAV1 
				and 0.0 <= initial_pos_UAV2
				and 0.0 <= initial_pos_UAV3
				--and initial positions are <= P
				and initial_pos_UAV1 <= DPSS_Constants.P_GLOBAL
 				and initial_pos_UAV2 <= DPSS_Constants.P_GLOBAL
 				and initial_pos_UAV3 <= DPSS_Constants.P_GLOBAL
				)
				-> true;
				
			assume "Initial directions are LEFT or RIGHT":
				((			initial_direction_UAV1 = DPSS_Constants.LEFT
						or  initial_direction_UAV1 = DPSS_Constants.RIGHT)
					and (	initial_direction_UAV2 = DPSS_Constants.LEFT
						or 	initial_direction_UAV2 = DPSS_Constants.RIGHT)
					and (	initial_direction_UAV3 = DPSS_Constants.LEFT
						or 	initial_direction_UAV3 = DPSS_Constants.RIGHT)
				)
				-> true;

			-----------------------------------------------------
			--GUARANTEES
			-----------------------------------------------------
			
			-- Main Theorem			
			guarantee "Theorem 1 for Algorithm A for 3 Vehicles":
				(time >= 
					((2.0*DPSS_Constants.N_real - 1.0)/DPSS_Constants.N_real)
					*DPSS_Constants.T
				) =>
					(	optimal and 
						deltaT = DPSS_Constants.T/DPSS_Constants.N_real
					);
			
			-- Main Theorem, v2		
			guarantee "Theorem 1 for Algorithm A for 3 Vehicles (v2)":
				(time >= 2.0*DPSS_Constants.T) =>
					(	optimal and 
						deltaT = DPSS_Constants.T/DPSS_Constants.N_real
					);
			
			guarantee "Initial positions are the input initial positions":
				(	pos_UAV1 = initial_pos_UAV1
				and pos_UAV2 = initial_pos_UAV2
				and pos_UAV3 = initial_pos_UAV3) -> true;
			
			guarantee "Goals are in bounds":
				--Goals are >= 0
					0.0 <= goal_UAV1
				and 0.0 <= goal_UAV2
				and 0.0 <= goal_UAV3
				--and goals are <=P
				and goal_UAV1 <= DPSS_Constants.P_GLOBAL
				and goal_UAV2 <= DPSS_Constants.P_GLOBAL
				and goal_UAV3 <= DPSS_Constants.P_GLOBAL;	
			
			guarantee "Positions are in bounds":
				--Positions are >= 0
					0.0 <= pos_UAV1
				and 0.0 <= pos_UAV2	 
				and 0.0 <= pos_UAV3
				--and positions are <= P
				and pos_UAV1 <= DPSS_Constants.P_GLOBAL
				and pos_UAV2 <= DPSS_Constants.P_GLOBAL
				and pos_UAV3 <= DPSS_Constants.P_GLOBAL;
			
			guarantee "UAVs stay in order":
					pos_UAV1 <= pos_UAV2
				and pos_UAV2 <= pos_UAV3;
			
			guarantee "UAVs turn around at the borders":
				--UAVs turn around at 0
					(pos_UAV1 = 0.0 => direction_UAV1 = DPSS_Constants.RIGHT)
				and (pos_UAV2 = 0.0 => direction_UAV2 = DPSS_Constants.RIGHT)
				and (pos_UAV3 = 0.0 => direction_UAV3 = DPSS_Constants.RIGHT)
				--and UAVs turn around at P
				and (pos_UAV1 = DPSS_Constants.P_GLOBAL => direction_UAV1 = DPSS_Constants.LEFT)
				and (pos_UAV2 = DPSS_Constants.P_GLOBAL => direction_UAV2 = DPSS_Constants.LEFT)
				and (pos_UAV3 = DPSS_Constants.P_GLOBAL => direction_UAV3 = DPSS_Constants.LEFT);
				
			guarantee "Directions are in bounds":
				(	 direction_UAV1 = DPSS_Constants.RIGHT or direction_UAV1 = DPSS_Constants.LEFT)
				and (direction_UAV2 = DPSS_Constants.RIGHT or direction_UAV2 = DPSS_Constants.LEFT)
				and (direction_UAV3 = DPSS_Constants.RIGHT or direction_UAV3 = DPSS_Constants.LEFT);
			
		**};
		
	end DPSS_3_Vehicles_AlgA;

	system implementation DPSS_3_Vehicles_AlgA.Impl
		subcomponents
			UAV1: system UAV_Pkg::UAV;
			UAV2: system UAV_Pkg::UAV;
			UAV3: system UAV_Pkg::UAV;
			
		connections
			--Initial directions
			init_dir_UAV1: port	initial_direction_UAV1 -> UAV1.initial_direction;
			init_dir_UAV2: port	initial_direction_UAV2 -> UAV2.initial_direction;
			init_dir_UAV3: port	initial_direction_UAV3 -> UAV3.initial_direction;
						
		annex agree {**

			--Assign direction variables (used at the system level)
			assign direction_UAV1 = UAV1.direction;
			assign direction_UAV2 = UAV2.direction;
			assign direction_UAV3 = UAV3.direction;
			
			--Assign goal variables (used at the system level)
			assign goal_UAV1 = UAV1.goal;
			assign goal_UAV2 = UAV2.goal;
			assign goal_UAV3 = UAV3.goal;
			
			--Assign positions
			assign pos_UAV1 = (initial_pos_UAV1 -> (if pre_direction_UAV1 = 1 then pre_pos_UAV1 + DPSS_Constants.V*(time - pre(time)) else pre_pos_UAV1 - DPSS_Constants.V*(time - pre(time))));
			assign pos_UAV2 = (initial_pos_UAV2 -> (if pre_direction_UAV2 = 1 then pre_pos_UAV2 + DPSS_Constants.V*(time - pre(time)) else pre_pos_UAV2 - DPSS_Constants.V*(time - pre(time))));
			assign pos_UAV3 = (initial_pos_UAV3 -> (if pre_direction_UAV3 = 1 then pre_pos_UAV3 + DPSS_Constants.V*(time - pre(time)) else pre_pos_UAV3 - DPSS_Constants.V*(time - pre(time))));
			
			--Set UAV IDs
			--We use assertions since the IDs are not system-level inputs that we can pass through
			assert UAV1.n_id = 1;			
			assert UAV2.n_id = 2;			
			assert UAV3.n_id = 3;
						
			--Set the meet_LN variables for each UAV
			assert UAV1.meet_LN = false; --There is no left neighbor to UAV1
			assert UAV2.meet_LN = (pos_UAV1 = pos_UAV2);
			assert UAV3.meet_LN = (pos_UAV2 = pos_UAV3);
			
			--Set the meet_RN variables for each UAV
			assert UAV1.meet_RN = (pos_UAV1 = pos_UAV2);
			assert UAV2.meet_RN = (pos_UAV2 = pos_UAV3);
			assert UAV3.meet_RN = false; --There is no right neighbor to UAVN
			
			--Tell the vehicles their current positions
			assert UAV1.pos = pos_UAV1;
			assert UAV2.pos = pos_UAV2;
			assert UAV3.pos = pos_UAV3;
			
			--Used in lemmas
			eq steps : int = 1 -> pre(steps) + 1;
			
			----------------------------------------------------------------------------
			--OBSERVERS (Invalid lemmas that produce examples of behavior of interest)
			----------------------------------------------------------------------------
						
			lemma "Observer: Worst time (nearly 2T) convergence":
				not (
					optimal
					--Initially, all UAVs are heading to the right
					and DPSS_Node_Lib.initial_value_true(direction_UAV1 = DPSS_Constants.RIGHT)
					and DPSS_Node_Lib.initial_value_true(direction_UAV2 = DPSS_Constants.RIGHT)
					and DPSS_Node_Lib.initial_value_true(direction_UAV3 = DPSS_Constants.RIGHT)
					--and the UAVs are located close together on the left end of the perimeter
					and DPSS_Node_Lib.initial_value_true(pos_UAV1 = 0.0)
					and DPSS_Node_Lib.initial_value_true(pos_UAV2 = 0.01)
					and DPSS_Node_Lib.initial_value_true(pos_UAV3 = 0.02)
				);
				
			lemma "Observer: Not yet optimal after 10 steps":
				steps = 10 => optimal;
			
			----------------------------------------------------------------------------
			--LEMMAS (We expect these to be true and to potentially help the model checker prove the guarantees)
			----------------------------------------------------------------------------			

			--UAVs stay in bounds (prove one at a time)	
			lemma "UAV1 stays in bounds": 0.0 <= pos_UAV1 and pos_UAV1 <= DPSS_Constants.P_GLOBAL;
			lemma "UAV2 stays in bounds": 0.0 <= pos_UAV2 and pos_UAV2 <= DPSS_Constants.P_GLOBAL;
			lemma "UAV3 stays in bounds": 0.0 <= pos_UAV3 and pos_UAV3 <= DPSS_Constants.P_GLOBAL;		
							
			lemma "Once in the optimal configuration, it stays there":
				true -> pre(optimal)	=> optimal;
					
			lemma "Optimal on and after 11 steps":
				steps >= 11 => optimal;
			
			lemma "Optimal implies deltaT = T/N":
				optimal => deltaT = DPSS_Constants.T/DPSS_Constants.N_real;
			
			lemma "deltaT is strictly between 0 and T":
				true -> (
					deltaT > 0.0 
					and deltaT < DPSS_Constants.T
					);
					
			-- This is a good way to find the real time bound!
 			-- The lemma is valid for time < 2T but not for time < (2-1/N)T.
 			-- I believe it would be valid with (2-1/N)T if we only required one timestep of stability instead of two. 			
			lemma "Time to optimal configuration is less than 2T":
				(optimal and not (pre(optimal))) => 
					(time < 2.0*DPSS_Constants.T);
			
			lemma "Observer: A 'worst time' case":
				(optimal and not (pre(optimal))) => 
					(time < 2.0*DPSS_Constants.T - 0.001);
			
			lemma "(Invalid) Worst case time => UAVs are clustered close to an endpoint and heading in the same direction":
				(optimal and not pre(optimal) and (time > 2.0*DPSS_Constants.T - 0.001))
				=> ((--Initially, all UAVs are heading to the right
						DPSS_Node_Lib.initial_value_true(direction_UAV1 = DPSS_Constants.RIGHT)
					and DPSS_Node_Lib.initial_value_true(direction_UAV2 = DPSS_Constants.RIGHT)
					and DPSS_Node_Lib.initial_value_true(direction_UAV3 = DPSS_Constants.RIGHT)
					--and the UAVs are located close together on the left end of the perimeter
					and DPSS_Node_Lib.initial_value_true(pos_UAV3 <= 0.001))
					or (
					--Initially, all UAVs are heading to the left
						DPSS_Node_Lib.initial_value_true(direction_UAV1 = DPSS_Constants.LEFT)
					and DPSS_Node_Lib.initial_value_true(direction_UAV2 = DPSS_Constants.LEFT)
					and DPSS_Node_Lib.initial_value_true(direction_UAV3 = DPSS_Constants.LEFT)
					--and the UAVs are located close together on the right end of the perimeter
					and DPSS_Node_Lib.initial_value_true(pos_UAV1 >= 9.999)
					));
				
			lemma "Worst case time => UAVs are clustered close to an endpoint":
				(optimal and not pre(optimal) and (time > 2.0*DPSS_Constants.T - 0.001))
				=> ((--Initially, the UAVs are located close together on the left end of the perimeter
						DPSS_Node_Lib.initial_value_true(pos_UAV3 <= 0.001)
					-- and the rightmost UAV is heading right
					and DPSS_Node_Lib.initial_value_true(direction_UAV3 = DPSS_Constants.RIGHT))
				or (
					--Initially, the UAVs are located close together on the right end of the perimeter
						DPSS_Node_Lib.initial_value_true(pos_UAV1 >= 9.999)
					-- and the leftmost UAV is heading left
					and DPSS_Node_Lib.initial_value_true(direction_UAV1 = DPSS_Constants.LEFT)
					));
				
		**};
		
	end DPSS_3_Vehicles_AlgA.Impl;

end DPSS_3_Vehicles_AlgA_Pkg;