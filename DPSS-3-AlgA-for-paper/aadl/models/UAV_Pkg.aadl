package UAV_Pkg
public
	--with DPSS_Data_Types;
	with Base_Types;
	with DPSS_Constants;
	 
	system UAV
		features
			--Inputs
			--Initial direction, set by system and essentially constrained by system-level assumptions
			initial_direction : in data port Base_Types::Integer; --The UAV may choose a different direction for the initial timestep, depending on the circumstances.
			--This UAV's position, updated by system after an event
			pos : in data port Base_Types::Float;
			--Set by system when right/left neighbor is co-located
			meet_LN : in data port Base_Types::Boolean; --True iff this UAV and its left neighbor are co-located
			meet_RN : in data port Base_Types::Boolean; --True iff this UAV and its right neighbor are co-located
			--The index, or ID, of this UAV, set at the system level
			n_id : in data port Base_Types::Integer; --a positive integer between 1 and N
			
			--Outputs
			-- This UAV's current direction and goal
			direction: out data port Base_Types::Integer;
			goal : out data port Base_Types::Float;
					
		annex agree {**
			
			-----------------------------------------------------
			--STATE VARIABLES
			-----------------------------------------------------		
				
			--Shared border positions
			eq S_L : real = real(n_id-1)*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;  
			eq S_R : real = real(n_id)*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;	
				
			--Previous direction
			eq pre_direction : int = 
				prev(direction, initial_direction);
									
			-----------------------------------------------------
			--ASSUMPTIONS
			-----------------------------------------------------		
			
			assume "n_id in range":
				n_id >= 1 and n_id <= DPSS_Constants.N_int;
						
			assume "n_id is fixed":
				true -> (n_id = pre(n_id));
									
			assume "Initial direction is LEFT or RIGHT":
				(		initial_direction = DPSS_Constants.LEFT
					or 	initial_direction = DPSS_Constants.RIGHT)
				-> true;
				
			-----------------------------------------------------
			--GUARANTEES
			-----------------------------------------------------		

			guarantee "Direction formula":
				direction = (
					-- Turn around at the left boundary.
					if pos <= 0.0 then
						DPSS_Constants.RIGHT
					else 
						-- Turn around at the right boundary.
						if pos >= DPSS_Constants.P_GLOBAL then
							DPSS_Constants.LEFT
						else 
							-- If meeting left neighbor, travel together toward shared border.
							if meet_LN then
								if pos <= S_L then
									DPSS_Constants.RIGHT
								else --pos > S_L
									DPSS_Constants.LEFT
							else
								-- If meeting right neighbor, travel together toward shared border.
							  	if meet_RN then
									if pos < S_R then
										DPSS_Constants.RIGHT
									else --pos >= S_R
										DPSS_Constants.LEFT 
								-- In all other cases, proceed in the same direction.
								else 
									pre_direction
				);  

			guarantee "Goal formula":
				goal = (
						if meet_LN and meet_RN then
							if pos <= S_L then
								S_R
							else -- pos > S_L
								S_L 
						else		
							if meet_LN then
								if pos <= S_L then
									DPSS_Constants.P_GLOBAL
								else -- pos > S_L
									S_L
							else 
								if meet_RN then
									if pos >= S_R then
										0.0
									else -- pos < S_R
										S_R
								else 
									if direction = DPSS_Constants.RIGHT then
										DPSS_Constants.P_GLOBAL
									else --direction = DPSS_Constants.LEFT 
										0.0 
				); 
			
		**};
		
	end UAV;
end UAV_Pkg;